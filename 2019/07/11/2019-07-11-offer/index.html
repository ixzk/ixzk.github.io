<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>《剑指Offer》题目总结 | XuZhengke</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="对《剑指Offer》一书中出现的题目进行总结。 部分新颖的题目或者思路采用 [*] 标签进行标记 牛客网在线训练链接：挑战剑指Offer  二叉树的遍历 通过递归进行前序、中序、后序遍历二叉树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 3">
<meta property="og:type" content="article">
<meta property="og:title" content="《剑指Offer》题目总结">
<meta property="og:url" content="http://xuzhengke.cn/2019/07/11/2019-07-11-offer/index.html">
<meta property="og:site_name" content="XuZhengke">
<meta property="og:description" content="对《剑指Offer》一书中出现的题目进行总结。 部分新颖的题目或者思路采用 [*] 标签进行标记 牛客网在线训练链接：挑战剑指Offer  二叉树的遍历 通过递归进行前序、中序、后序遍历二叉树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 3">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-07-10T16:00:00.000Z">
<meta property="article:modified_time" content="2020-07-20T12:42:21.501Z">
<meta property="article:author" content="xuzhengke">
<meta name="twitter:card" content="summary">
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/10.1.0/styles/github.min.css">
  <script src="//cdn.bootcss.com/highlight.js/10.1.1/highlight.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      document.querySelectorAll('pre code').forEach((block) => {
        hljs.highlightBlock(block);
      });
    });
  </script>
  <script>hljs.initHighlightingOnLoad();</script>
  
<link rel="stylesheet" href="/css/index.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body style="


  background-color: #eff0f6

">
  <div id="container">
    <nav id="nav">
  <header class="header">
    <a href="/" class="title">XuZhengke</a>
  </header>
  <div class="ctnWrap">
    <div class="icons">
      
        
          
            <a href="https://github.com/ixzk" target="_blank" class="nav-icn iconfont icon-github"></a>
          
        
      
    </div>
    <div class="menu">
      
        
            <a href="/" class="nav-menu ">首页</a>
          
        
            <a href="/archives" class="nav-menu ">归档</a>
          
        
            <a href="/categories" class="nav-menu ">分类</a>
          
        
            <a href="/about" class="nav-menu ">关于我</a>
          
        
      
    </div>
  </div>
</nav>
    <div id="main"><section class="article">
  <h2 class="title">《剑指Offer》题目总结</h2>
  <p class="sub">Jul 11, 2019</p>
  <article class="content">
    <blockquote>
<p>对《剑指Offer》一书中出现的题目进行总结。<br>部分新颖的题目或者思路采用 <strong>[*]</strong> 标签进行标记<br>牛客网在线训练链接：<a href="https://www.nowcoder.com/ta/coding-interviews" target="_blank" rel="noopener">挑战剑指Offer</a></p>
</blockquote>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><h3 id="通过递归进行前序、中序、后序遍历二叉树"><a href="#通过递归进行前序、中序、后序遍历二叉树" class="headerlink" title="通过递归进行前序、中序、后序遍历二叉树"></a>通过递归进行前序、中序、后序遍历二叉树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先序遍历</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(Node *node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, node-&gt;val);<br><br>    <span class="hljs-comment">// 遍历左子树</span><br>    preOrder(node-&gt;left);<br><br>    <span class="hljs-comment">// 遍历右子树</span><br>    preOrder(node-&gt;right);<br>&#125;<br><br><span class="hljs-comment">// 中序遍历</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(Node *node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ;<br><br>    <span class="hljs-comment">// 遍历左子树</span><br>    inOrder(node-&gt;left);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, node-&gt;val);<br><br>    <span class="hljs-comment">// 遍历右子树</span><br>    inOrder(node-&gt;right);<br>&#125;<br><br><span class="hljs-comment">// 后续遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(Node *node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ;<br><br>    <span class="hljs-comment">// 遍历左子树</span><br>    postOrder(node-&gt;left);<br><br>    <span class="hljs-comment">// 遍历右子树</span><br>    postOrder(node-&gt;right);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, node-&gt;val);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="通过非递归前序、中序、后序遍历二叉树"><a href="#通过非递归前序、中序、后序遍历二叉树" class="headerlink" title="通过非递归前序、中序、后序遍历二叉树"></a>通过非递归前序、中序、后序遍历二叉树</h3><p>思路:<br>递归就是一个栈的调用过程，所以非递归遍历的时候也要引入栈来实现。<br><a href="https://blog.csdn.net/silence1772/article/details/83623336" target="_blank" rel="noopener">https://blog.csdn.net/silence1772/article/details/83623336</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 非递归先序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(Node *root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ;<br><br>    <span class="hljs-built_in">stack</span>&lt;Node *&gt; <span class="hljs-built_in">stack</span>;<br>    <span class="hljs-built_in">stack</span>.push(root);<br><br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">stack</span>.empty()) &#123;<br>        Node *node = <span class="hljs-built_in">stack</span>.top();<br>        <span class="hljs-built_in">stack</span>.pop();<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, node-&gt;val);<br><br>        <span class="hljs-keyword">if</span> (node-&gt;right) <span class="hljs-built_in">stack</span>.push(node-&gt;right);<br>        <span class="hljs-keyword">if</span> (node-&gt;left) <span class="hljs-built_in">stack</span>.push(node-&gt;left);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 非递归中序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(Node *root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ;<br><br>    <span class="hljs-built_in">stack</span>&lt;Node *&gt; <span class="hljs-built_in">stack</span>;<br>    Node *node = head;<br><br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">stack</span>.empty() || node != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">while</span>(node != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-built_in">stack</span>.push(node);<br>            node = node-&gt;left;<br>        &#125;<br><br>        node = <span class="hljs-built_in">stack</span>.top();<br>        <span class="hljs-built_in">stack</span>.pop();<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, node-&gt;val);<br><br>        node = node-&gt;right;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 非递归后序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postNode</span><span class="hljs-params">(Node *root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ;<br><br>    Node *last = <span class="hljs-literal">nullptr</span>;<br>    Node *node = root;<br><br>    <span class="hljs-built_in">stack</span>&lt;Node *&gt; <span class="hljs-built_in">stack</span>;<br>    <span class="hljs-built_in">stack</span>.push(node);<br><br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">stack</span>.empty()) &#123;<br>        node = <span class="hljs-built_in">stack</span>.top();<br><br>        <span class="hljs-comment">// 三种可以打印根节点的情况</span><br>        <span class="hljs-keyword">if</span> ((node-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">nullptr</span>) ||<br>            (last == node-&gt;left &amp;&amp; node-&gt;right == <span class="hljs-literal">nullptr</span>) ||<br>             last == node-&gt;right) &#123;<br>            <br>            <span class="hljs-comment">// 1. 无左右节点</span><br>            <span class="hljs-comment">// 2. 左节点遍历完，右节点为空</span><br>            <span class="hljs-comment">// 3. 上一个打印的节点是右节点</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, node-&gt;val);<br>            <span class="hljs-built_in">stack</span>.pop();<br>            last = node;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (node-&gt;right) <span class="hljs-built_in">stack</span>.push(node-&gt;right);<br>            <span class="hljs-keyword">if</span> (node-&gt;left) <span class="hljs-built_in">stack</span>.push(node-&gt;left);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="代码的鲁棒性"><a href="#代码的鲁棒性" class="headerlink" title="代码的鲁棒性"></a>代码的鲁棒性</h2><h3 id="22-链表中倒数第k个指针"><a href="#22-链表中倒数第k个指针" class="headerlink" title="22. 链表中倒数第k个指针"></a>22. 链表中倒数第k个指针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入一个链表，输出该链表中倒数第k个结点。(倒数第一个为最后一个)<br></code></pre></td></tr></table></figure>

<p>思路: 采用快慢指针的方法，倒数第k个，就先让快指针走k-1步，然后快慢指针一起走，当快指针到最后一个节点时，慢指针指向的为倒数第k个指针。</p>
<p>注意:</p>
<ul>
<li>倒数第1个是最后一个，倒数第二个的话，应该是快指针在结尾，慢指针指向倒数第二个，以此类推，快慢指针应该间隔(k-1)个节点。</li>
<li>记得判断链表是否有k个节点长。</li>
</ul>
<h3 id="24-翻转链表"><a href="#24-翻转链表" class="headerlink" title="[*] 24. 翻转链表"></a>[*] 24. 翻转链表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入一个链表，反转链表后，输出新链表的表头。<br></code></pre></td></tr></table></figure>

<p>思路: 主要是保存前节点和后节点，防止链表断开。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (pHead == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        ListNode *pReversedHead = <span class="hljs-literal">nullptr</span>;<br>        ListNode *pPre = <span class="hljs-literal">nullptr</span>;<br>        ListNode *pNode = pHead;<br><br>        <span class="hljs-keyword">while</span> (pNode != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode *pNext = pNode-&gt;next;<br>            <span class="hljs-keyword">if</span> (pNext == <span class="hljs-literal">nullptr</span>) &#123;<br>                pReversedHead = pNode;<br>            &#125;<br><br>            pNode-&gt;next = pPre;<br>            pPre = pNode;<br>            pNode = pNext;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> pReversedHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25. 合并两个排序的链表"></a>25. 合并两个排序的链表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。<br></code></pre></td></tr></table></figure>

<p>思路:<br>可用循环，可用递归，较为简单。</p>
<h3 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="[*] 26. 树的子结构"></a>[*] 26. 树的子结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入两棵二叉树A，B，判断B是不是A的子结构。<br></code></pre></td></tr></table></figure>

<p>思路:</p>
<ol>
<li>先遍历树的每一个节点，看A是否存在某个节点与B的根节点相同</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">HasSubtree</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span><br><span class="hljs-function">    </span>&#123;<br>    <span class="hljs-keyword">if</span> (pRoot1 == <span class="hljs-literal">nullptr</span> || pRoot2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">bool</span> res = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (pRoot1-&gt;val == pRoot2-&gt;val) &#123;<br>        res = DoesTree1HasTree2(pRoot1, pRoot2);<br>    &#125;<br>    <br> <span class="hljs-comment">// 根节点不符合要求，继续查找左结点</span><br>    <span class="hljs-keyword">if</span> (!res) &#123;<br>        res = HasSubtree(pRoot1-&gt;left, pRoot2);<br>    &#125;<br><br> <span class="hljs-comment">// 左节点不符合要求，继续查找右节点。</span><br>    <span class="hljs-keyword">if</span> (!res) &#123;<br>        res = HasSubtree(pRoot1-&gt;right, pRoot2);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2.当在A中找到与B根节点相等的节点时，挨个去比对AB树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DoesTree1HasTree2</span><span class="hljs-params">(TreeNode *pRoot1, TreeNode *pRoot2)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (pRoot1 == <span class="hljs-literal">nullptr</span> || pRoot2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> (pRoot1-&gt;val != pRoot2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> DoesTree1HasTree2(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; DoesTree1HasTree2(pRoot1-&gt;right, pRoot2-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="代码的完整性"><a href="#代码的完整性" class="headerlink" title="代码的完整性"></a>代码的完整性</h2><h3 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16. 数值的整数次方"></a>16. 数值的整数次方</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br></code></pre></td></tr></table></figure>

<p>思路: [*]</p>
<p>如果按照正常思路做的话，需要考虑好数的范围，指数的正负等情况。</p>
<p>可以考虑使用递归的方式去解决</p>
<p>an = an/2 * an/2 (n为偶数)</p>
<p>an = an-1/2 * an-1/2 * a (n为基数)</p>
<p>最后考虑指数的正负问题即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Power</span><span class="hljs-params">(<span class="hljs-keyword">double</span> base, <span class="hljs-keyword">int</span> exponent)</span> </span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> unexp = <span class="hljs-built_in">abs</span>(exponent);<br><br>    <span class="hljs-keyword">if</span> (unexp == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (unexp == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> base;<br><br> <span class="hljs-comment">// unexp &gt;&gt; 1 强制转换成int, 所以可以暂时忽略基数的问题</span><br>    <span class="hljs-keyword">double</span> res = Power(base, unexp &gt;&gt; <span class="hljs-number">1</span>);<br>    res *= res;<br>    <span class="hljs-keyword">if</span> (unexp &amp; <span class="hljs-number">0x1</span> == <span class="hljs-number">1</span>) &#123;<br>        res *= base;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (exponent &gt; <span class="hljs-number">0</span> ? res : <span class="hljs-number">1</span> / res);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21. 调整数组顺序使奇数位于偶数前面"></a>21. 调整数组顺序使奇数位于偶数前面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">题目1: 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。<br><br>题目2: 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，*并保证奇数和奇数，偶数和偶数之间的相对位置不变。*<br></code></pre></td></tr></table></figure>

<p>思路：</p>
<p>假如输入内容为: [1,2,3,4,5,6,7]</p>
<p>第一题: 第一题没有考虑排序的稳定性，也就是更换之后不需要考虑相对位置。可以考虑前后指针往中间查询，前指针直到查询到第一个偶数为止，后指针直到查询到第一个基数位置，然后做交换。</p>
<hr>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="15-二进制中1的位数"><a href="#15-二进制中1的位数" class="headerlink" title="15. 二进制中1的位数"></a>15. 二进制中1的位数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入一个整数n，输出该数二进制表示中1的个数。<br></code></pre></td></tr></table></figure>

<p>思路:</p>
<ul>
<li>正常思路是循环右移整数n，然后和1做与运算判断最后一位是否是1，直到为0时结束。但是这种方式仅仅适用于正数，因为负数右移时会一直补充1，这样就会出现最后全为1，导致死循环。</li>
<li>因为每次移位后都与1(flag)做与运算去查看最后一位是否是1，可以转换思路，每次不再是n右移，而是flag左移，然后n与flag与运算是否是等于flag，也可以判断每一位是否是1。但是写代码的时候要注意一个优先级问题。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>     <span class="hljs-keyword">int</span> flag = <span class="hljs-number">1</span>;<br>     <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>     <span class="hljs-keyword">while</span> (flag) &#123;<br>        <span class="hljs-comment">// 注意这里有一个算数优先级问题</span><br>        <span class="hljs-comment">// 最开始的写法是</span><br>        <span class="hljs-comment">// if (flag &amp; n == flag) 注意运算时没有加括号</span><br>        <span class="hljs-comment">// 导致结果一直错误</span><br>        <span class="hljs-keyword">if</span> ((flag &amp; n) == flag) count++;<br>        <br>        flag = flag &lt;&lt; <span class="hljs-number">1</span>;<br>     &#125;<br><br>     <span class="hljs-keyword">return</span> count;<br> &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>[*] 以2进制 n = 0010 1100 为例子<ol>
<li>a = n – 1，如果最低位为0，就会向前借位，直到碰到第一个1，此时 a 为 0010 1011, 相当于第一个1左边不变，自己变为0，右边的0全部变为1。</li>
<li>b = a &amp; n, 由1知道，第一个1左侧不变，右侧取反，此时b 为 0010 1000, 也就是从第一个1开始，右侧所有数变为0</li>
<li>以此循环下去，直到n变为0000 0000</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (n) &#123;<br>       count++;<br>       n = (n - <span class="hljs-number">1</span>) &amp; n;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4. 二维数组中的查找"></a>4. 二维数组中的查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br></code></pre></td></tr></table></figure>

<p>思路:<br>可从右上角(左下角)考虑，因为这两个角可以通过与target对比大小，然后决定舍弃一行还是一列的问题。</p>
<h3 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="[*] 66. 构建乘积数组"></a>[*] 66. 构建乘积数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]&#x3D;A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。<br></code></pre></td></tr></table></figure>

<p>思路：<br>B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1] 可以写成<br>B[i] = C[i] * 1 * D[i];<br>其中<br>C[i] = C[i – 1] * A[i – 1];<br>D[i] = D[i + 1] * A[i + 1];</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; A)</span> </span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; B;<br>    <span class="hljs-keyword">int</span> n = A.<span class="hljs-built_in">size</span>();<br><br>    B.push_back(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n;i++) &#123;<br>        B.push_back(B[i - <span class="hljs-number">1</span>] * A[i - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">double</span> temp = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        temp *= A[i + <span class="hljs-number">1</span>];<br>        B[i] *= temp;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> B;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5. 替换空格"></a>5. 替换空格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br></code></pre></td></tr></table></figure>

<p>思路:<br>考虑从后往前复制，可以减少字母的移动。</p>
<p>**</p>
<h2 id="递归和循环"><a href="#递归和循环" class="headerlink" title="递归和循环"></a>递归和循环</h2><h3 id="10-斐波那契数列"><a href="#10-斐波那契数列" class="headerlink" title="10. 斐波那契数列"></a>10. 斐波那契数列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>n&lt;&#x3D;39<br></code></pre></td></tr></table></figure>

<p>思路:<br>传统的递归容易产生重复计算，可以考虑从下到上的方式计算。</p>
<h3 id="10-2-跳台阶"><a href="#10-2-跳台阶" class="headerlink" title="10.2 跳台阶"></a>10.2 跳台阶</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。<br></code></pre></td></tr></table></figure>

<p>思路:<br>一开始没理解为什么采用斐波那契。<br>1级台阶有1种跳法，2级有(11, 2)两种跳法，3级有(11, 12, 21)3种；<br>当有n阶时，如果第一步跳了1个，那么剩下的跳法是f(n-1)种，如果第一步跳了2个，剩下的跳法是f(n-2)种，所以f(n) = f(n-1) + f(n-2)</p>
<h3 id="10-3-变态跳台阶"><a href="#10-3-变态跳台阶" class="headerlink" title="10.3 变态跳台阶"></a>10.3 变态跳台阶</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br></code></pre></td></tr></table></figure>

<p>思路:<br>比上一个题目有更多的可能性<br>1： 只有一种跳法<br>2： 第一步可以跳1下或者2下， 如果跳1下，那么剩下的台阶有f(2-1)种可能，如果跳两下则有f(2-2)种可能。 f(2) = f(2-1) + f(2-2)<br>3： 第一步可以跳1，2，3下，剩下的则有f(3-1),f(3-2),f(3-3)种。 f(3) = f(3-1)+f(3-2)+f(3-3)</p>
<p>总结:<br>f(n-1) = f(0) + f(1) + f(2) …. + f(n-2)<br>f(n) = f(0) + f(1) + f(2) …. + f(n-2) + f(n-1)</p>
<p>所以: f(n) = f(n-1) + f(n-1) = 2 * f(n-1)</p>
<p>f(0) = 1;<br>f(1) = 1;<br>f(n) = 2 * f(n-1)</p>
<h3 id="10-4-矩形覆盖"><a href="#10-4-矩形覆盖" class="headerlink" title="10.4 矩形覆盖"></a>10.4 矩形覆盖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？<br></code></pre></td></tr></table></figure>

<p>思路：<br>通过画图可以了解规律<br>\1. n = 1, 1种<br>\2. n = 2, 2种<br>\3. n = 3, 如果第一块砖已经确定，则有f(3-1)种铺法，如果两块转铺好则有f(3-2)种铺法<br>\4. 总结 f(n) = f(n-1) + f(n-2)</p>
<hr>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="6-从头到尾打印链表"><a href="#6-从头到尾打印链表" class="headerlink" title="6. 从头到尾打印链表"></a>6. 从头到尾打印链表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。<br></code></pre></td></tr></table></figure>

<p>思路:<br>此过程是一个先进后出(后进先出)的过程，可以考虑使用一个栈来实现。当然递归本质上也是一个种栈结构。</p>
<ul>
<li>栈实现，后进先出</li>
<li>递归，先递归到结尾，然后依次回到每一个节点。</li>
</ul>
<h3 id="18-删除链表中重复的节点"><a href="#18-删除链表中重复的节点" class="headerlink" title="18. 删除链表中重复的节点"></a>18. 删除链表中重复的节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5<br></code></pre></td></tr></table></figure>

<h3 id="23-链表中环的入口结点"><a href="#23-链表中环的入口结点" class="headerlink" title="23. 链表中环的入口结点"></a>23. 链表中环的入口结点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。<br></code></pre></td></tr></table></figure>

<p>思路:<br>\1. 先找出是否存在环，快慢指针法，快指针2步走，慢指针1步走；<br>\2. 循环链环，找出环的长度len；<br>\3. 快指针先走len，这样快慢指针相差的距离就是环的长度。</p>
<p>注意:<br>在判断是否存在闭环的时候，需要注意两点<br>\1. 开始时快慢指针不要都从pHead开始，因为如果一开始两指针就指向pHead的话，循环在第一步就终结；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode *fast = pHead-&gt;next;<br>ListNode *slow = pHead;<br><br><span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">nullptr</span> &amp;&amp; slow != <span class="hljs-literal">nullptr</span>)<br></code></pre></td></tr></table></figure>

<ol>
<li>因为快指针每次需要多走一步，所以要经常判断快指针是否为null；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">fast = fast-&gt;next;<br><span class="hljs-keyword">if</span> (fast != <span class="hljs-literal">nullptr</span>) fast = fast-&gt;next;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><hr>
<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="9-用两个栈实现队列"><a href="#9-用两个栈实现队列" class="headerlink" title="9. 用两个栈实现队列"></a>9. 用两个栈实现队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br></code></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>push: 只需要往stack1中添加即可。</li>
<li>pop: 如果stack2中有元素，直接弹出栈顶即可，如果没有元素，则将stack1的元素依次出栈然后放入stack2中。类似于把stack1中的元素倒入stack2。</li>
</ul>
<hr>
<h2 id="面试思路"><a href="#面试思路" class="headerlink" title="面试思路"></a>面试思路</h2><h3 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27. 二叉树的镜像"></a>27. 二叉树的镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">题目描述<br>操作给定的二叉树，将其变换为源二叉树的镜像。<br>输入描述:<br>二叉树的镜像定义：源二叉树 <br>            8<br>           &#x2F;  \<br>          6   10<br>         &#x2F; \  &#x2F; \<br>        5  7 9 11<br>        镜像二叉树<br>            8<br>           &#x2F;  \<br>          10   6<br>         &#x2F; \  &#x2F; \<br>        11 9 7  5<br></code></pre></td></tr></table></figure>

<p>思路：<br>递归，每次都只交换自己的左右节点即可。</p>
<p>注意：<br>终结状态不光要判断pRoot == null， 还要判断 (pRoot-&gt;left == null &amp;&amp; pRoot-&gt;right == null) 是&amp;&amp;不是||， 因为只有一个子节点时也可以做镜像操作。</p>
<hr>
<h2 id="举例让抽象具体化"><a href="#举例让抽象具体化" class="headerlink" title="举例让抽象具体化"></a>举例让抽象具体化</h2><h3 id="32-从上到下打印二叉树"><a href="#32-从上到下打印二叉树" class="headerlink" title="32. 从上到下打印二叉树"></a>32. 从上到下打印二叉树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">从上往下打印出二叉树的每个节点，同层节点从左至右打印。<br></code></pre></td></tr></table></figure>

<p>思路：<br>题目较为简单，考虑先进先出，通过队列即可解决。</p>
<p>注意： 队列是queue，在C++中queue的第一个元素为front()而不是top().</p>
<hr>
<h2 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h2><h3 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。<br>输入描述:<br>输入一个字符串,包括数字字母符号,可以为空<br>输出描述:<br>如果是合法的数值表达则返回该数字，否则返回0<br></code></pre></td></tr></table></figure>

<p>思路:<br>可以考虑正常的转换过程</p>
<p>注意:<br>\1. 输入不合法的时候除了返回0，还应该设置一个全局变量表示输入无效；<br>\2. 允许输入+/-符号；<br>\3. 如果可能的话，还要判断数值的边界。</p>
<hr>
<h2 id="知识迁移能力"><a href="#知识迁移能力" class="headerlink" title="知识迁移能力"></a>知识迁移能力</h2><h3 id="53-数字在排序数组中出现的次数"><a href="#53-数字在排序数组中出现的次数" class="headerlink" title="53. 数字在排序数组中出现的次数"></a>53. 数字在排序数组中出现的次数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">统计一个数字在排序数组中出现的次数。<br></code></pre></td></tr></table></figure>

<p>思路：<br>题目的主要目的是找到firstK和lastK，可以通过二分法单独去找firstK和lastK, 找到后做减法即可。因为是O(logn), 所以多查一个也没有关系。</p>
<p>注意:<br>在判断是否是fisrtK的时候，需要判断是否是数组中的第0个数字，如果不是的话，需要判断一下这个数的前一个数是什么数。同理可以找到lastK。</p>
<h3 id="55-二叉树的深度"><a href="#55-二叉树的深度" class="headerlink" title="55. 二叉树的深度"></a>55. 二叉树的深度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。<br></code></pre></td></tr></table></figure>

<p>思路:<br>不要考虑的太复杂，一个树的深度计算为： 左子树高度和右子树高度相对较大的一个+1； 所以可以考虑采用递归的方式去实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">TreeDepth</span><span class="hljs-params">(TreeNode* pRoot)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (pRoot == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">int</span> leftHeight = TreeDepth(pRoot-&gt;left);<br>    <span class="hljs-keyword">int</span> rightHeight = TreeDepth(pRoot-&gt;right);<br><br>    <span class="hljs-keyword">return</span> (leftHeight &gt; rightHeight ? leftHeight + <span class="hljs-number">1</span> : rightHeight + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="55-2-平衡二叉树"><a href="#55-2-平衡二叉树" class="headerlink" title="55.2 平衡二叉树"></a>55.2 平衡二叉树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入一棵二叉树，判断该二叉树是否是平衡二叉树。<br></code></pre></td></tr></table></figure>

<p>思路：<br>\1. 根据55题目去判断左子树和右子树的高度，不过会有重复计算的节点。<br>\2. 遍历到每个节点时可以通过判断左右子树的深度去判断它是不是平衡的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsBalanced_Solution</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> IsBalancedCore(pRoot, &amp;depth);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsBalancedCore</span><span class="hljs-params">(TreeNode *pRoot, <span class="hljs-keyword">int</span> *depth)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pRoot == <span class="hljs-literal">nullptr</span>) &#123;<br>        *depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> left, right;<br>    <span class="hljs-keyword">if</span> (IsBalancedCore(pRoot-&gt;left, &amp;left) &amp;&amp; IsBalancedCore(pRoot-&gt;right, &amp;right)) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(left - right) &lt;= <span class="hljs-number">1</span>) &#123;<br>            *depth = <span class="hljs-number">1</span> + (left &gt; right ? left : right);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：<br>平衡二叉树是要判断每个节点，而不是单纯只判断pRoot的左右子树深度差。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 错误</span><br><span class="hljs-keyword">return</span> (diff &lt;= <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 正确</span><br><span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">return</span> IsBalanced_Solution(pRoot-&gt;left) &amp;&amp; IsBalanced_Solution(pRoot-&gt;right)<br></code></pre></td></tr></table></figure>

<h3 id="56-数组中只出现一次的两个数字"><a href="#56-数组中只出现一次的两个数字" class="headerlink" title="56. 数组中只出现一次的两个数字"></a>56. 数组中只出现一次的两个数字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。<br></code></pre></td></tr></table></figure>

<p>思路：<br>异或运算，可通过异或运算的结果求其中一个为1的位，为1的原因是因为这两个数该为是不一样的，所以可以区分开。</p>
<h3 id="57-和为S的两个数字"><a href="#57-和为S的两个数字" class="headerlink" title="57. 和为S的两个数字"></a>57. 和为S的两个数字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。<br></code></pre></td></tr></table></figure>

<p>思路:<br>考虑头指针和尾指针的方式，当和小于S时，增大头指针，当和大于S时，减小尾指针。</p>
<h3 id="57-2-和为S的连续正数序列"><a href="#57-2-和为S的连续正数序列" class="headerlink" title="57.2 和为S的连续正数序列"></a>57.2 和为S的连续正数序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序<br></code></pre></td></tr></table></figure>

<p>思路:<br>从第一个数和第二个数开始做加法，如果小于当前值，则end+1，如果大于当前值，则start+1,记得和要先减去start。 前提是保证start &lt; end 和start 小于中位数。</p>
<h3 id="58-翻转字符串"><a href="#58-翻转字符串" class="headerlink" title="58. 翻转字符串"></a>58. 翻转字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">I am a student. &#x3D;&#x3D;&gt; student. a am I<br></code></pre></td></tr></table></figure>

<p>思路:<br>一开始翻转一次，最后在以空格为分隔符继续翻转每个单词</p>
<p>注意:<br>如果以遇到空格时才做翻转，那么在while循环外需要再做一次翻转(比如一个单词的情况)；</p>
<h3 id="58-2-左旋转字符串"><a href="#58-2-左旋转字符串" class="headerlink" title="58.2 左旋转字符串"></a>58.2 左旋转字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">字符序列S&#x3D;”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”<br></code></pre></td></tr></table></figure>

<p>思路：<br>和58题相同的思路，甚至简单，只需要先把整个翻转，然后根据输入的数字n将字符串分为两个单词，各自翻转。</p>

  </article>
  <footer class="f-cf">
    
      <a href="/2019/07/14/2019-07-14-iOS-download/" class="link f-fl">⟵iOS – 使用“AFNetworking”实现一个下载器 (思路)</a>
    
    
      <a href="/2019/07/11/2019-07-11-iOS-%E2%80%93-AFNetworking/" class="link f-fr">iOS – AFNetworking部分解析⟶</a>
    
  </footer>
</section></div>
    <footer id="footer" class="f-cf">
  xzkjob@gmail.com
  
    
      
        · <a href="https://github.com/ixzk" target="_blank" class="nav-icn">GitHub</a>
      
    
  
  <span class="copyright">All rights reserved @ZhengkeXu</span>
</footer>
<script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1260869892'%3E%3C/span%3E%3Cscript src='https://s4.cnzz.com/z_stat.php%3Fid%3D1260869892%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script>
  </div>
</body>
</html>